chaduke

medium

# Two withdraw transactions might have a race condition in the same block, one will succeed and the other will fail.

## Summary
Two withdraw transactions might have a race condition in the same block, one will succeed and the other will fail. The main reason is that the current implementation of ``ProtectionPoolCycleManager.calculateAndSetPoolCycleState()`` forces an open state to go through a locked state first, before transitioning to another open state, even in the case that the whole cycle has already completed and there is a need to go from an open state DIRECTLY to another open state (without the need to transition to a locked state first).

## Vulnerability Detail
In the following, we analyze why two withdraw transactions might have a race condition in the same block, which is not supposed to be. 

1) Suppose each cycle is 7 days, thus, ``cycleDuration = 7 days``, and ``openCycleDuration = 7 days``. Suppose ``currentCycleIndex = 100``, and we are in day 2, therefore, we have ``currentCycleState = ProtectionPoolCycleState.Open``.

2) Suppose 6 days passed and nobody calls ``calculateAndSetPoolCycleState()`` in these 6 days. Now we are in day 8. Therefore,  we still have ``currentCycleState = ProtectionPoolCycleState.Open``. 

3) We have two withdraw transactions coming on the same block. We will see that the first withdraw (``withdraw1``) will always fail and the second withdraw (``withdraw2``) will succeed (assume everything else is OK). 

4) The ``withdraw()`` function will call the modifier ``whenPoolIsOpen()``, which calls ``poolCycleManager.calculateAndSetPoolCycleState(address(this)`` to transition the state of the protection pool when necessary. 

```javascript
function withdraw(uint256 _sTokenWithdrawalAmount, address _receiver)
    external
    override
    whenPoolIsOpen
    whenNotPaused
    nonReentrant
  {
    /// Step 1: Retrieve withdrawal details for current pool cycle index
    uint256 _currentCycleIndex = poolCycleManager.getCurrentCycleIndex(
      address(this)
    );
    WithdrawalCycleDetail storage withdrawalCycle = withdrawalCycleDetails[
      _currentCycleIndex
    ];

    /// Step 2: Verify withdrawal request exists in this withdrawal cycle for the user
    uint256 _sTokenRequested = withdrawalCycle.withdrawalRequests[msg.sender];
    if (_sTokenRequested == 0) {
      revert NoWithdrawalRequested(msg.sender, _currentCycleIndex);
    }

    /// Step 3: Verify that withdrawal amount is not more than the requested amount.
    if (_sTokenWithdrawalAmount > _sTokenRequested) {
      revert WithdrawalHigherThanRequested(msg.sender, _sTokenRequested);
    }

    /// Step 4: calculate underlying amount to transfer based on sToken withdrawal amount
    uint256 _underlyingAmountToTransfer = convertToUnderlying(
      _sTokenWithdrawalAmount
    );

    /// Step 5: burn sTokens shares.
    /// This step must be done after calculating underlying amount to be transferred
    _burn(msg.sender, _sTokenWithdrawalAmount);

    /// Step 6: Update total sToken underlying amount
    totalSTokenUnderlying -= _underlyingAmountToTransfer;

    /// Step 7: update seller's withdrawal amount and total requested withdrawal amount
    withdrawalCycle.withdrawalRequests[msg.sender] -= _sTokenWithdrawalAmount;
    withdrawalCycle.totalSTokenRequested -= _sTokenWithdrawalAmount;

    /// Step 8: transfer underlying token to receiver
    poolInfo.underlyingToken.safeTransfer(
      _receiver,
      _underlyingAmountToTransfer
    );

    emit WithdrawalMade(msg.sender, _sTokenWithdrawalAmount, _receiver);
  }
modifier whenPoolIsOpen() {
    /// Update the pool cycle state
    ProtectionPoolCycleState cycleState = poolCycleManager
      .calculateAndSetPoolCycleState(address(this));

    if (cycleState != ProtectionPoolCycleState.Open) {
      revert ProtectionPoolIsNotOpen();
    }
    _;
  }
```

5) However, as one can see, since the pool is in ``open`` state, although 6 days passed and the state should transition directly o another ``open`` state, due to the state transition machine design, the state has to go through the ``locked`` state first after the first call of ``poolCycleManager.calculateAndSetPoolCycleState(address(this)``, and then transition to ``open`` state in the next call of ``poolCycleManager.calculateAndSetPoolCycleState(address(this)``. Therefore, withdraw1 will fail due to the state is in ``locked`` state, and then ``withdraw2`` will succeed since the state is now in ``open`` state, although they are both in the same block. 
This should not be the case. A redesign of the state transition machine is necessary: when the whole cycle has already completed, a state should be able to transit from an open state to another open state of the new cycle. 

[https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/ProtectionPoolCycleManager.sol#L94-L143](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/ProtectionPoolCycleManager.sol#L94-L143)




## Impact
Two withdraw transactions might have a race condition in the same block, one will succeed and the other will fail. So the fairness property is compromised. 


## Code Snippet
See above

## Tool used
VSCode

Manual Review

## Recommendation
We revise the state transition machine to allow the transition from ``open`` to ``open`` when it fits. 
```diff
function calculateAndSetPoolCycleState(address _protectionPoolAddress)
    external
    override
    returns (ProtectionPoolCycleState _newState)
  {
    ProtectionPoolCycle storage poolCycle = protectionPoolCycles[
      _protectionPoolAddress
    ];

    /// Gas optimization:
    /// Store the current cycle state in memory instead of reading it from the storage multiple times.
    ProtectionPoolCycleState currentState = _newState = poolCycle
      .currentCycleState;

    /// If cycle is not started, that means pool is NOT registered yet.
    /// So, we can't move the cycle state
    if (currentState == ProtectionPoolCycleState.None) {
      return _newState;
    }

    /// If cycle is open, then check if it's time to move to LOCKED state.
    if (currentState == ProtectionPoolCycleState.Open) {
      /// If current time is past the initial open duration, then move to LOCKED state.
      if (
        block.timestamp - poolCycle.currentCycleStartTime >
        poolCycle.params.openCycleDuration
+     && block.timestamp - poolCycle.currentCycleStartTime <= // @audit: if not yet next cycle
+       poolCycle.params.cycleDuration
      ) {
        poolCycle.currentCycleState = _newState = ProtectionPoolCycleState
          .Locked;
      }
    }
    /// If cycle is locked, then check if it's time to start a new cycle.
-    else if (currentState == ProtectionPoolCycleState.Locked) {
+   else {
      /// If current time is past the total cycle duration, then start a new cycle.
      if (
        block.timestamp - poolCycle.currentCycleStartTime >
        poolCycle.params.cycleDuration
      ) {
        /// move current cycle to a new cycle
        _startNewCycle(
          _protectionPoolAddress,
          poolCycle,
          poolCycle.currentCycleIndex + 1
        );
        _newState = ProtectionPoolCycleState.Open;
      }
    }
```
